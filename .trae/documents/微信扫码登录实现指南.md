# 微信扫码登录实现指南

## 1. 实现概述

本指南详细说明如何在MemBuddy项目中实现微信扫码登录功能。基于现有的微信小程序登录架构，扩展支持微信开放平台网站应用的扫码登录。

## 2. 环境配置

### 2.1 微信开放平台配置

确保在 `.env` 文件中配置了以下微信开放平台参数：

```env
# 微信开放平台网站应用配置
WECHAT_WEB_APP_ID=wx1d809b67fce7aaca
WECHAT_WEB_APP_SECRET=659c83344dc5739eb097dfae5a846e26
```

### 2.2 前端环境变量

在前端项目中添加环境变量配置：

```env
# .env.local
NEXT_PUBLIC_WECHAT_WEB_APP_ID=wx1d809b67fce7aaca
NEXT_PUBLIC_WECHAT_REDIRECT_URL=http://localhost:3000/auth/wechat/callback
```

## 3. 后端实现

### 3.1 扩展Schemas

在 `schemas.py` 中添加微信网站应用登录的数据结构：

```python
# 微信网站应用登录请求
class WechatWebLoginRequest(BaseModel):
    code: str
    state: str

# 微信授权URL生成请求
class WechatQrCodeRequest(BaseModel):
    redirect_uri: Optional[str] = None

# 微信授权URL响应
class WechatQrCodeResponse(BaseModel):
    auth_url: str
    state: str
```

### 3.2 扩展配置文件

在 `config.py` 中确保包含微信网站应用配置：

```python
class Settings(BaseSettings):
    # ... 现有配置 ...
    
    # WeChat Web App Configuration
    WECHAT_WEB_APP_ID: str = os.getenv("WECHAT_WEB_APP_ID", "")
    WECHAT_WEB_APP_SECRET: str = os.getenv("WECHAT_WEB_APP_SECRET", "")
```

### 3.3 实现微信网站应用登录API

在 `routers/auth.py` 中添加以下接口：

```python
@router.get("/wechat/qrcode", response_model=schemas.WechatQrCodeResponse)
def generate_wechat_qrcode(redirect_uri: Optional[str] = None, supabase: Client = Depends(get_anon_supabase)):
    """
    生成微信授权二维码URL
    """
    try:
        # 生成随机state参数
        state = str(uuid.uuid4()).replace('-', '')
        
        # 存储state到数据库，设置过期时间
        supabase.table("wechat_auth_states").insert({
            "state": state,
            "expires_at": (datetime.utcnow() + timedelta(minutes=10)).isoformat()
        }).execute()
        
        # 构建回调URL
        if not redirect_uri:
            redirect_uri = f"{settings.FRONTEND_URL}/auth/wechat/callback"
        
        # 构建微信授权URL
        auth_url = (
            f"https://open.weixin.qq.com/connect/qrconnect?"
            f"appid={settings.WECHAT_WEB_APP_ID}&"
            f"redirect_uri={requests.utils.quote(redirect_uri)}&"
            f"response_type=code&"
            f"scope=snsapi_login&"
            f"state={state}#wechat_redirect"
        )
        
        return schemas.WechatQrCodeResponse(
            auth_url=auth_url,
            state=state
        )
        
    except Exception as e:
        logger.error(f"Generate WeChat QR code error: {e}")
        raise HTTPException(status_code=500, detail="Failed to generate QR code")

@router.post("/wechat/web")
def wechat_web_login(request: schemas.WechatWebLoginRequest, supabase: Client = Depends(get_anon_supabase)):
    """
    微信网站应用登录
    """
    try:
        # 1. 验证state参数
        state_result = supabase.table("wechat_auth_states").select("*").eq("state", request.state).eq("used", False).execute()
        
        if not state_result.data:
            raise HTTPException(status_code=400, detail="Invalid or expired state parameter")
        
        state_record = state_result.data[0]
        
        # 检查是否过期
        expires_at = datetime.fromisoformat(state_record["expires_at"].replace('Z', '+00:00'))
        if datetime.utcnow().replace(tzinfo=timezone.utc) > expires_at:
            raise HTTPException(status_code=400, detail="State parameter expired")
        
        # 标记state为已使用
        supabase.table("wechat_auth_states").update({"used": True}).eq("id", state_record["id"]).execute()
        
        # 2. 使用code获取access_token
        token_url = "https://api.weixin.qq.com/sns/oauth2/access_token"
        token_params = {
            "appid": settings.WECHAT_WEB_APP_ID,
            "secret": settings.WECHAT_WEB_APP_SECRET,
            "code": request.code,
            "grant_type": "authorization_code"
        }
        
        token_response = requests.get(token_url, params=token_params)
        token_data = token_response.json()
        
        if "errcode" in token_data:
            raise HTTPException(status_code=400, detail=f"WeChat API error: {token_data.get('errmsg', 'Unknown error')}")
        
        access_token = token_data.get("access_token")
        openid = token_data.get("openid")
        unionid = token_data.get("unionid")
        
        if not access_token or not openid:
            raise HTTPException(status_code=400, detail="Failed to get access token from WeChat")
        
        # 3. 获取用户信息
        userinfo_url = "https://api.weixin.qq.com/sns/userinfo"
        userinfo_params = {
            "access_token": access_token,
            "openid": openid,
            "lang": "zh_CN"
        }
        
        userinfo_response = requests.get(userinfo_url, params=userinfo_params)
        userinfo_data = userinfo_response.json()
        
        if "errcode" in userinfo_data:
            raise HTTPException(status_code=400, detail=f"Failed to get user info: {userinfo_data.get('errmsg', 'Unknown error')}")
        
        # 4. 查找或创建用户
        user_query = supabase.table("users").select("*").eq("wechat_openid", openid)
        if unionid:
            user_query = user_query.or_(f"wechat_unionid.eq.{unionid}")
        
        existing_user = user_query.execute()
        
        if existing_user.data:
            # 用户已存在，更新信息
            user_data = existing_user.data[0]
            update_data = {
                "wechat_openid": openid,
                "wechat_unionid": unionid,
                "wechat_nickname": userinfo_data.get("nickname"),
                "wechat_avatar": userinfo_data.get("headimgurl")
            }
            supabase.table("users").update(update_data).eq("id", user_data["id"]).execute()
            user_id = user_data["id"]
            email = user_data.get("email", f"wechat_{openid}@membuddy.local")
            full_name = user_data.get("full_name") or userinfo_data.get("nickname", "微信用户")
        else:
            # 创建新用户
            new_user_data = {
                "id": str(uuid.uuid4()),
                "email": f"wechat_{openid}@membuddy.local",
                "full_name": userinfo_data.get("nickname", "微信用户"),
                "wechat_openid": openid,
                "wechat_unionid": unionid,
                "wechat_nickname": userinfo_data.get("nickname"),
                "wechat_avatar": userinfo_data.get("headimgurl")
            }
            
            result = supabase.table("users").insert(new_user_data).execute()
            if not result.data:
                raise HTTPException(status_code=500, detail="Failed to create user")
            
            user_id = new_user_data["id"]
            email = new_user_data["email"]
            full_name = new_user_data["full_name"]
        
        # 5. 生成JWT token
        access_token = jwt.encode({
            "sub": user_id,
            "email": email,
            "full_name": full_name,
            "exp": datetime.utcnow().timestamp() + 86400 * 30  # 30天过期
        }, settings.SUPABASE_JWT_SECRET, algorithm="HS256")
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "user": schemas.User(
                id=user_id, 
                email=email, 
                full_name=full_name,
                wechat_openid=openid,
                wechat_unionid=unionid
            )
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"WeChat web login error: {e}")
        raise HTTPException(status_code=500, detail="WeChat login failed")
```

## 4. 前端实现

### 4.1 创建微信授权回调页面

创建 `app/auth/wechat/callback/page.tsx`：

```tsx
"use client"

import { useEffect, useState } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import { Loader2 } from "lucide-react"
import { api } from "@/lib/api-config"

export default function WechatCallbackPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading')
  const [message, setMessage] = useState('正在处理微信授权...')

  useEffect(() => {
    const handleWechatCallback = async () => {
      try {
        const code = searchParams.get('code')
        const state = searchParams.get('state')

        if (!code || !state) {
          setStatus('error')
          setMessage('授权参数缺失')
          return
        }

        // 调用后端API处理微信登录
        const response = await fetch(`${api.baseURL}/api/auth/wechat/web`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ code, state }),
        })

        const data = await response.json()

        if (response.ok) {
          // 登录成功，保存token
          localStorage.setItem('token', data.access_token)
          localStorage.setItem('user', JSON.stringify(data.user))
          
          // 通知父窗口登录成功
          if (window.opener) {
            window.opener.postMessage({ type: 'WECHAT_LOGIN_SUCCESS', data }, '*')
            window.close()
          } else {
            // 如果不是弹窗，直接跳转
            setStatus('success')
            setMessage('登录成功，正在跳转...')
            setTimeout(() => {
              router.push('/')
            }, 1000)
          }
        } else {
          setStatus('error')
          setMessage(data.detail || '登录失败')
        }
      } catch (error) {
        console.error('WeChat callback error:', error)
        setStatus('error')
        setMessage('网络错误，请重试')
      }
    }

    handleWechatCallback()
  }, [searchParams, router])

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-900 via-blue-800 to-blue-900 flex items-center justify-center">
      <div className="bg-white/10 backdrop-blur-sm border border-white/20 rounded-lg p-8 text-center">
        {status === 'loading' && (
          <>
            <Loader2 className="h-8 w-8 animate-spin mx-auto mb-4 text-white" />
            <p className="text-white">{message}</p>
          </>
        )}
        {status === 'success' && (
          <>
            <div className="h-8 w-8 bg-green-500 rounded-full mx-auto mb-4 flex items-center justify-center">
              <svg className="h-5 w-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
              </svg>
            </div>
            <p className="text-white">{message}</p>
          </>
        )}
        {status === 'error' && (
          <>
            <div className="h-8 w-8 bg-red-500 rounded-full mx-auto mb-4 flex items-center justify-center">
              <svg className="h-5 w-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </div>
            <p className="text-white">{message}</p>
            <button 
              onClick={() => window.close()} 
              className="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              关闭窗口
            </button>
          </>
        )}
      </div>
    </div>
  )
}
```

### 4.2 更新登录表单组件

在现有的 `components/auth/login-form.tsx` 中更新微信登录逻辑：

```tsx
// 在现有的handleWechatLogin函数中更新实现
const handleWechatLogin = async () => {
  if (isWechatLoading) return

  try {
    setIsWechatLoading(true)
    
    // 调用后端API生成授权URL
    const response = await fetch(`${api.baseURL}/api/auth/wechat/qrcode`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })
    
    const data = await response.json()
    
    if (response.ok) {
      // 生成二维码并显示
      setQrCodeUrl(data.auth_url)
      setShowQrCode(true)
      
      // 延迟生成二维码，确保对话框已完全渲染
      setTimeout(async () => {
        await generateQrCode(data.auth_url)
      }, 100)
      
      // 开始轮询检查登录状态
      startPolling(data.state)
    } else {
      toast({
        title: "生成二维码失败",
        description: data.detail || "请稍后重试",
        variant: "destructive",
      })
    }
  } catch (error) {
    console.error('WeChat login error:', error)
    toast({
      title: "网络错误",
      description: "请检查网络连接后重试",
      variant: "destructive",
    })
  } finally {
    setIsWechatLoading(false)
  }
}

// 更新轮询逻辑，监听postMessage事件
useEffect(() => {
  const handleMessage = (event: MessageEvent) => {
    if (event.data.type === 'WECHAT_LOGIN_SUCCESS') {
      // 登录成功，关闭二维码对话框
      setShowQrCode(false)
      if (pollingInterval) {
        clearInterval(pollingInterval)
        setPollingInterval(null)
      }
      
      // 跳转到主页面
      router.push('/')
      
      toast({
        title: "登录成功",
        description: "欢迎使用MemBuddy！",
      })
    }
  }
  
  window.addEventListener('message', handleMessage)
  
  return () => {
    window.removeEventListener('message', handleMessage)
  }
}, [router, pollingInterval])
```

## 5. 数据库迁移

在Supabase中执行以下SQL语句：

```sql
-- 创建微信授权状态表
CREATE TABLE IF NOT EXISTS wechat_auth_states (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    state VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '10 minutes'),
    used BOOLEAN DEFAULT FALSE
);

-- 创建索引
CREATE INDEX idx_wechat_auth_states_state ON wechat_auth_states(state);
CREATE INDEX idx_wechat_auth_states_expires_at ON wechat_auth_states(expires_at);

-- 设置权限
GRANT SELECT, INSERT, UPDATE ON wechat_auth_states TO anon;
GRANT ALL PRIVILEGES ON wechat_auth_states TO authenticated;

-- 为用户表添加微信字段（如果不存在）
ALTER TABLE users ADD COLUMN IF NOT EXISTS wechat_openid VARCHAR(255) UNIQUE;
ALTER TABLE users ADD COLUMN IF NOT EXISTS wechat_unionid VARCHAR(255);
ALTER TABLE users ADD COLUMN IF NOT EXISTS wechat_nickname VARCHAR(255);
ALTER TABLE users ADD COLUMN IF NOT EXISTS wechat_avatar TEXT;

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_users_wechat_openid ON users(wechat_openid);
CREATE INDEX IF NOT EXISTS idx_users_wechat_unionid ON users(wechat_unionid);
```

## 6. 测试验证

### 6.1 功能测试

1. **二维码生成测试**：访问登录页面，点击微信扫码登录，验证二维码正常生成
2. **扫码登录测试**：使用微信扫描二维码，验证授权流程和登录成功
3. **新用户注册测试**：使用未注册的微信账号扫码，验证自动注册功能
4. **已有用户绑定测试**：已注册用户扫码登录，验证账号绑定功能

### 6.2 安全测试

1. **State参数验证**：测试无效或过期的state参数是否被正确拒绝
2. **重复使用防护**：测试同一个授权码是否只能使用一次
3. **超时处理**：测试授权超时的处理机制

## 7. 部署注意事项

1. **域名配置**：确保微信开放平台配置的授权回调域名与实际部署域名一致
2. **HTTPS要求**：生产环境必须使用HTTPS协议
3. **环境变量**：确保生产环境正确配置所有微信相关的环境变量
4. **日志监控**：配置适当的日志记录，便于问题排查

通过以上实现，MemBuddy项目将具备完整的微信扫码登录功能，为用户提供便捷的第三方登录体验。